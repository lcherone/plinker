{
    "docs": [
        {
            "location": "/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute generic PHP \ncomponents on remote systems, while maintaining the feel of a local method call.\n\n\nInstall\n\n\nEach component is in a composer package.\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\nVersion\n\n\n\n\n\n\n\n\n\n\ncore\n\n\nRequired base component which contains the client and server.\n\n\n\n\n\n\n\n\n\n\n*Some components require further steps.\n\n\nDevelopment repository\n\n\nIf you would like to contribute then use the \ndevelopment repository\n.\n\n\nThe repository is used to develop the entire project, to make it easy to work on many parts at the same time without forgetting what was done,\nit also contains bash scripts which will commit and do semantic versioning for each sub component and build this documentation.\n\n\nInstall\n\n\n\n\ngit clone git@github.com:plinker-rpc/development.git .\n\n\n\n\ncomposer install\n\n\n\n\n\n\n Lorem ipsum dolor sit amet, consectetur adipiscing elit\n\n\n\n\n Nulla lobortis egestas semper\n\n\n Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est\n\n\n Vestibulum convallis sit amet nisi a tincidunt\n\n\n In hac habitasse platea dictumst\n\n\n In scelerisque nibh non dolor mollis congue sed et metus\n\n\n Sed egestas felis quis elit dapibus, ac aliquet turpis mattis\n\n\n Praesent sed risus massa\n\n\n\n\n\n\n Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque\n\n\n Nulla vel eros venenatis, imperdiet enim id, faucibus nisi\n\n\n\n\nCommitting changes:\n\n\n\n\n.\n/\nphp\n-\ncs\n-\nfixer\n \nfix\n \n.\n/\nvendor\n/\nplinker\n \n--\nverbose\n \n--\nrules\n=\n@\nPSR2\n \n--\ndry\n-\nrun\n \n--\ndiff\n\n\nbash ./commit.sh \nAn informative commit message\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed here.", 
            "title": "Home"
        }, 
        {
            "location": "/#install", 
            "text": "Each component is in a composer package.     Component  Description  Version      core  Required base component which contains the client and server.      *Some components require further steps.", 
            "title": "Install"
        }, 
        {
            "location": "/#development-repository", 
            "text": "If you would like to contribute then use the  development repository .  The repository is used to develop the entire project, to make it easy to work on many parts at the same time without forgetting what was done,\nit also contains bash scripts which will commit and do semantic versioning for each sub component and build this documentation.", 
            "title": "Development repository"
        }, 
        {
            "location": "/#install_1", 
            "text": "git clone git@github.com:plinker-rpc/development.git .   composer install     Lorem ipsum dolor sit amet, consectetur adipiscing elit    Nulla lobortis egestas semper   Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est   Vestibulum convallis sit amet nisi a tincidunt   In hac habitasse platea dictumst   In scelerisque nibh non dolor mollis congue sed et metus   Sed egestas felis quis elit dapibus, ac aliquet turpis mattis   Praesent sed risus massa     Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque   Nulla vel eros venenatis, imperdiet enim id, faucibus nisi   Committing changes:   . / php - cs - fixer   fix   . / vendor / plinker   -- verbose   -- rules = @ PSR2   -- dry - run   -- diff  bash ./commit.sh  An informative commit message", 
            "title": "Install"
        }, 
        {
            "location": "/#development-encouragement", 
            "text": "If you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.", 
            "title": "Development Encouragement"
        }, 
        {
            "location": "/#sponsors", 
            "text": "Get your company or name listed here.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/asterisk/", 
            "text": "Plinker-RPC - Asterisk\n\n\n\n\nNo longer in development\n\n\nThis component is no longer being developed.\n\n\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nAn Asterisk component which hooks into the Asterisk Management Interface on remote systems.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/asterisk\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\nWIP: To be updated with info on how to use this component, also add the tasks code.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $url to host\n\n\n * @param string $component namespace of class to interface to\n\n\n * @param string $public_key to authenticate on host\n\n\n * @param string $private_key to authenticate on host\n\n\n * @param string $config component construct config\n\n\n */\n\n\n$plink\n \n=\n \nnew\n \nPlinker\\Core\\Client\n(\n\n    \nhttp://example.com\n,\n\n    \nTest\\Demo\n,\n\n    \nusername\n,\n\n    \npassword\n,\n\n    \narray\n(\n\n        \ntime\n \n=\n \ntime\n()\n\n    \n)\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$plink\n-\ntest\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Asterisk"
        }, 
        {
            "location": "/asterisk/#plinker-rpc-asterisk", 
            "text": "No longer in development  This component is no longer being developed.   PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  An Asterisk component which hooks into the Asterisk Management Interface on remote systems.  Composer  {\n     require : {\n         plinker/core :  =v0.1 ,\n         plinker/asterisk :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - Asterisk"
        }, 
        {
            "location": "/asterisk/#making-a-remote-call", 
            "text": "WIP: To be updated with info on how to use this component, also add the tasks code.  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $url to host   * @param string $component namespace of class to interface to   * @param string $public_key to authenticate on host   * @param string $private_key to authenticate on host   * @param string $config component construct config   */  $plink   =   new   Plinker\\Core\\Client ( \n     http://example.com , \n     Test\\Demo , \n     username , \n     password , \n     array ( \n         time   =   time () \n     )  );  echo   pre . print_r ( $plink - test (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/base91/", 
            "text": "Plinker-RPC - Base91\n\n\nA core component, which base91 encodes the payload, you do not need to include it as its included with core.\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Base91"
        }, 
        {
            "location": "/base91/#plinker-rpc-base91", 
            "text": "A core component, which base91 encodes the payload, you do not need to include it as its included with core.  See the  organisations page  for additional components.", 
            "title": "Plinker-RPC - Base91"
        }, 
        {
            "location": "/core/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute generic PHP components on remote systems, while maintaining the feel of a local method call.\n\n\nDocs:\n \nhttps://plinker-rpc.github.io/core\n\n\nNew changes in version 3 include:\n\n\n\n\nNow compaible with \nPHP extension\n.\n\n\nBuilt-in core components and info method added so components can be discovered.\n\n\nOnly one client instance is now needed, made use of __get() to dynamically set component.\n\n\nUser defined components/classes, so you can call your own code.\n\n\nBoth request and response is encrypted and signed.\n\n\n\n\nInstall\n\n\nRequire this package with composer using the following command:\n\n\n$ composer require plinker/core\n\n\n\n\n\nAdditional Setup\n\n\nThis component does not require any additional setup.\n\n\nClient\n\n\nCreating a client instance is done as follows:\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $server - URL to server listener.\n\n\n * @param string $config - server secret, and/or a additional component data\n\n\n */\n\n\n$client\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \nhttp://example.com/server.php\n,\n\n    \n[\n\n        \nsecret\n \n=\n \na secret password\n,\n\n    \n]\n\n\n);\n\n\n\n// or using global function\n\n\n$client\n \n=\n \nplinker_client\n(\nhttp://example.com/server.php\n,\n \na secret password\n);\n\n\n\n\n\n\nServer\n\n\nCreating a server listener is done as follows:\n\n\nOptional features:\n\n\n\n\nSet a secret, which all clients will require. \n\n\nLock down to specific client IP addresses for addtional security.\n\n\nDefine your own classes in the \nclasses\n array then access like above \n$client-\nclass-\nmethod()\n, which can interface out of scope components or composer packages.\n\n\nDefine addtional key values for database connections etc, or you could pass the parameters through the client connection.\n\n\n\n\n\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker server.\n\n\n */\n\n\nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n    \n// init plinker server\n\n    \necho\n \n(\nnew\n \n\\Plinker\\Server\n([\n\n        \nsecret\n \n=\n \na secret password\n,\n\n        \nallowed_ips\n \n=\n \n[\n\n            \n127.0.0.1\n\n        \n],\n\n        \nclasses\n \n=\n \n[\n\n            \ntest\n \n=\n \n[\n\n                \n// path to file\n\n                \nclasses/test.php\n,\n\n                \n// addtional key/values\n\n                \n[\n\n                    \nkey\n \n=\n \nvalue\n\n                \n]\n\n            \n],\n\n            \n// you can use namespaced classes\n\n            \nFoo\\\\Demo\n \n=\n \n[\n\n                \n// path to file\n\n                \nsome_class/demo.php\n,\n\n                \n// addtional key/values\n\n                \n[\n\n                    \nkey\n \n=\n \nvalue\n\n                \n]\n\n            \n],\n\n            \n// ...\n\n        \n]\n\n    \n]))\n-\nlisten\n();\n\n\n}\n\n\n\n\n\n\nMethods\n\n\nOnce setup, you call the class though its namespace to its method.\n\n\nInfo\n\n\nThe info method returns defined endpoint methods and their parameters.\n\n\nCall\n\n\n$result = $client-\ninfo();\n\n\n\n\n\nResponse\n\n\nArray\n(\n    [class] =\n Array\n        (\n            [Foo\\Demo] =\n Array\n                (\n                    [config] =\n Array\n                        (\n                            [key] =\n value\n                        )\n\n                    [methods] =\n Array\n                        (\n                            [config] =\n Array\n                                (\n                                )\n\n                            [this] =\n Array\n                                (\n                                )\n\n                            [test] =\n Array\n                                (\n                                    [0] =\n x\n                                    [1] =\n y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)\n\n\n\n\n\nTesting\n\n\n$ composer \ntest\n\n\n\n\n\n\nContributing\n\n\nPlease see \nCONTRIBUTING\n for details.\n\n\nSecurity\n\n\nIf you discover any security related issues, please contact me via \nhttps://cherone.co.uk\n instead of using the issue tracker.\n\n\nCredits\n\n\n\n\nLawrence Cherone\n\n\nAll Contributors\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed here.\n\n\nLicense\n\n\nThe MIT License (MIT). Please see \nLicense File\n for more information.\n\n\nSee \norganisations page\n for additional components.", 
            "title": "Core"
        }, 
        {
            "location": "/core/#install", 
            "text": "Require this package with composer using the following command:  $ composer require plinker/core", 
            "title": "Install"
        }, 
        {
            "location": "/core/#additional-setup", 
            "text": "This component does not require any additional setup.", 
            "title": "Additional Setup"
        }, 
        {
            "location": "/core/#client", 
            "text": "Creating a client instance is done as follows:  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $server - URL to server listener.   * @param string $config - server secret, and/or a additional component data   */  $client   =   new   \\Plinker\\Core\\Client ( \n     http://example.com/server.php , \n     [ \n         secret   =   a secret password , \n     ]  );  // or using global function  $client   =   plinker_client ( http://example.com/server.php ,   a secret password );", 
            "title": "Client"
        }, 
        {
            "location": "/core/#server", 
            "text": "Creating a server listener is done as follows:  Optional features:   Set a secret, which all clients will require.   Lock down to specific client IP addresses for addtional security.  Define your own classes in the  classes  array then access like above  $client- class- method() , which can interface out of scope components or composer packages.  Define addtional key values for database connections etc, or you could pass the parameters through the client connection.    ?php  require   vendor/autoload.php ;  /**   * Initialize plinker server.   */  if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n     // init plinker server \n     echo   ( new   \\Plinker\\Server ([ \n         secret   =   a secret password , \n         allowed_ips   =   [ \n             127.0.0.1 \n         ], \n         classes   =   [ \n             test   =   [ \n                 // path to file \n                 classes/test.php , \n                 // addtional key/values \n                 [ \n                     key   =   value \n                 ] \n             ], \n             // you can use namespaced classes \n             Foo\\\\Demo   =   [ \n                 // path to file \n                 some_class/demo.php , \n                 // addtional key/values \n                 [ \n                     key   =   value \n                 ] \n             ], \n             // ... \n         ] \n     ])) - listen ();  }", 
            "title": "Server"
        }, 
        {
            "location": "/core/#methods", 
            "text": "Once setup, you call the class though its namespace to its method.", 
            "title": "Methods"
        }, 
        {
            "location": "/core/#info", 
            "text": "The info method returns defined endpoint methods and their parameters.  Call  $result = $client- info();  Response  Array\n(\n    [class] =  Array\n        (\n            [Foo\\Demo] =  Array\n                (\n                    [config] =  Array\n                        (\n                            [key] =  value\n                        )\n\n                    [methods] =  Array\n                        (\n                            [config] =  Array\n                                (\n                                )\n\n                            [this] =  Array\n                                (\n                                )\n\n                            [test] =  Array\n                                (\n                                    [0] =  x\n                                    [1] =  y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)", 
            "title": "Info"
        }, 
        {
            "location": "/core/#testing", 
            "text": "$ composer  test", 
            "title": "Testing"
        }, 
        {
            "location": "/core/#contributing", 
            "text": "Please see  CONTRIBUTING  for details.", 
            "title": "Contributing"
        }, 
        {
            "location": "/core/#security", 
            "text": "If you discover any security related issues, please contact me via  https://cherone.co.uk  instead of using the issue tracker.", 
            "title": "Security"
        }, 
        {
            "location": "/core/#credits", 
            "text": "Lawrence Cherone  All Contributors", 
            "title": "Credits"
        }, 
        {
            "location": "/core/#development-encouragement", 
            "text": "If you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.", 
            "title": "Development Encouragement"
        }, 
        {
            "location": "/core/#sponsors", 
            "text": "Get your company or name listed here.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/core/#license", 
            "text": "The MIT License (MIT). Please see  License File  for more information.  See  organisations page  for additional components.", 
            "title": "License"
        }, 
        {
            "location": "/cron/", 
            "text": "Plinker-RPC - CRON\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA cron component which allows you to read and control cron tasks.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/cron\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking remote calls.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/cron/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// optional config\n\n        \nconfig\n \n=\n \n[\n\n            \njournal\n \n=\n \n./crontab.journal\n,\n\n            \napply\n   \n=\n \nfalse\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$cron\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nCron\\Manager\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct array which you pass to the component\n\n        \n$config\n[\nconfig\n]\n\n    \n);\n\n\n    \n// get crontab as-is\n\n    \necho\n \nh2\n$cron-\ncrontab()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncrontab\n()\n.\n/pre\n;\n\n\n    \n// create a crontask\n\n    \necho\n \nh2\n$cron-\ncreate(\\\nMy Cron Task\\\n, \\\n* * * * * cd ~\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncreate\n(\nMy Cron Task\n,\n \n* * * * * cd ~\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// update cron task\n\n    \necho\n \nh2\n$cron-\nupdate(\\\nMy Cron Task\\\n, \\\n0 * * * * cd ~\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nupdate\n(\nMy Cron Task\n,\n \n0 * * * * cd ~\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// delete cron task\n\n    \necho\n \nh2\n$cron-\ndelete(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ndelete\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// drop cron task\n\n    \necho\n \nh2\n$cron-\ndrop()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ndrop\n()\n.\n/pre\n;\n\n\n    \n// get crontab as-is\n\n    \necho\n \nh2\n$cron-\ncrontab()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncrontab\n()\n.\n/pre\n;\n\n\n    \n// apply crontab\n\n    \necho\n \nh2\n$cron-\napply()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\napply\n()\n.\n/pre\n;\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Its POST..\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Its Plinker!\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n/**\n\n\n         * Define Plinker Config\n\n\n         */\n\n        \n$plinker\n \n=\n \n[\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n,\n\n            \n// optional config\n\n            \n/*\nconfig\n =\n [\n\n\n                // allowed ips, restrict access by ip\n\n\n                \nallowed_ips\n =\n [\n\n\n                    \n127.0.0.1\n\n\n                ]\n\n\n            ]*/\n\n        \n];\n\n\n        \n// init plinker server\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \n$plinker\n[\npublic_key\n],\n\n            \n$plinker\n[\nprivate_key\n],\n\n            \n(\narray\n)\n \n@\n$plinker\n[\nconfig\n]\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Cron"
        }, 
        {
            "location": "/cron/#plinker-rpc-cron", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A cron component which allows you to read and control cron tasks.  Composer  {\n     require : {\n         plinker/cron :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - CRON"
        }, 
        {
            "location": "/cron/#making-remote-calls", 
            "text": "?php  require   ../../vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/cron/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // optional config \n         config   =   [ \n             journal   =   ./crontab.journal , \n             apply     =   false \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $cron   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Cron\\Manager , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct array which you pass to the component \n         $config [ config ] \n     ); \n\n     // get crontab as-is \n     echo   h2 $cron- crontab() /h2 ; \n     echo   pre . $cron - crontab () . /pre ; \n\n     // create a crontask \n     echo   h2 $cron- create(\\ My Cron Task\\ , \\ * * * * * cd ~\\ ) /h2 ; \n     echo   pre . $cron - create ( My Cron Task ,   * * * * * cd ~ ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // update cron task \n     echo   h2 $cron- update(\\ My Cron Task\\ , \\ 0 * * * * cd ~\\ ) /h2 ; \n     echo   pre . $cron - update ( My Cron Task ,   0 * * * * cd ~ ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // delete cron task \n     echo   h2 $cron- delete(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - delete ( My Cron Task ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // drop cron task \n     echo   h2 $cron- drop() /h2 ; \n     echo   pre . $cron - drop () . /pre ; \n\n     // get crontab as-is \n     echo   h2 $cron- crontab() /h2 ; \n     echo   pre . $cron - crontab () . /pre ; \n\n     // apply crontab \n     echo   h2 $cron- apply() /h2 ; \n     echo   pre . $cron - apply () . /pre ;  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Its POST..   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Its Plinker!       */ \n     if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         /**           * Define Plinker Config           */ \n         $plinker   =   [ \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp , \n             // optional config \n             /* config  =  [                  // allowed ips, restrict access by ip                   allowed_ips  =  [                       127.0.0.1                  ]              ]*/ \n         ]; \n\n         // init plinker server \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             $plinker [ public_key ], \n             $plinker [ private_key ], \n             ( array )   @ $plinker [ config ] \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components.", 
            "title": "Making remote calls."
        }, 
        {
            "location": "/files/", 
            "text": "Plinker-RPC - Files\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA files component which allows you to read and write files.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/files\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking remote calls.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/cron/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// optional config\n\n        \nconfig\n \n=\n \n[\n\n            \njournal\n \n=\n \n./crontab.journal\n,\n\n            \napply\n   \n=\n \nfalse\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$cron\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nFiles\\Manager\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct array which you pass to the component\n\n        \n$config\n[\nconfig\n]\n\n    \n);\n\n\n    \n// todo!\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Its POST..\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Its Plinker!\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n/**\n\n\n         * Define Plinker Config\n\n\n         */\n\n        \n$plinker\n \n=\n \n[\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n,\n\n            \n// optional config\n\n            \n/*\nconfig\n =\n [\n\n\n                // allowed ips, restrict access by ip\n\n\n                \nallowed_ips\n =\n [\n\n\n                    \n127.0.0.1\n\n\n                ]\n\n\n            ]*/\n\n        \n];\n\n\n        \n// init plinker server\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \n$plinker\n[\npublic_key\n],\n\n            \n$plinker\n[\nprivate_key\n],\n\n            \n(\narray\n)\n \n@\n$plinker\n[\nconfig\n]\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Files"
        }, 
        {
            "location": "/files/#plinker-rpc-files", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A files component which allows you to read and write files.  Composer  {\n     require : {\n         plinker/files :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - Files"
        }, 
        {
            "location": "/files/#making-remote-calls", 
            "text": "?php  require   ../../vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/cron/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // optional config \n         config   =   [ \n             journal   =   ./crontab.journal , \n             apply     =   false \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $cron   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Files\\Manager , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct array which you pass to the component \n         $config [ config ] \n     ); \n\n     // todo!  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Its POST..   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Its Plinker!       */ \n     if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         /**           * Define Plinker Config           */ \n         $plinker   =   [ \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp , \n             // optional config \n             /* config  =  [                  // allowed ips, restrict access by ip                   allowed_ips  =  [                       127.0.0.1                  ]              ]*/ \n         ]; \n\n         // init plinker server \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             $plinker [ public_key ], \n             $plinker [ private_key ], \n             ( array )   @ $plinker [ config ] \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components.", 
            "title": "Making remote calls."
        }, 
        {
            "location": "/iptables/", 
            "text": "Plinker-RPC - Iptables\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nWIP: control iptables though rpc\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \nrequire\n: {\n        \nplinker/iptables\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nThen navigate to \n./vendor/plinker/iptables/scripts\n and run \nbash install.sh\n\n\n::Client::\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$\nconfig\n \n=\n \n[\n\n\n    \n//\n \nplinker\n \nconnection\n\n\n    \nplinker\n \n=\n \n[\n\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1:88\n,\n\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n\n    \n]\n,\n\n\n\n    \n//\n \ndatabase\n \nconnection\n\n\n    \ndatabase\n \n=\n \n[\n\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n\n        \nhost\n     \n=\n \n,\n\n\n        \nname\n     \n=\n \n,\n\n\n        \nusername\n \n=\n \n,\n\n\n        \npassword\n \n=\n \n,\n\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n\n    \n]\n\n\n];\n\n\n\n//\n \ninit\n \nplinker\n \nendpoint\n \nclient\n\n\n$\niptables\n \n=\n \nnew\n \n\\\nPlinker\n\\\nCore\n\\\nClient\n(\n\n\n    \n//\n \nwhere\n \nis\n \nthe\n \nplinker\n \nserver\n\n\n    \n$\nconfig\n[\nplinker\n][\nendpoint\n]\n,\n\n\n\n    \n//\n \ncomponent\n \nnamespace\n \nto\n \ninterface\n \nto\n\n\n    \nIptables\\Manager\n,\n\n\n\n    \n//\n \nkeys\n\n\n    \n$\nconfig\n[\nplinker\n][\npublic_key\n]\n,\n\n\n    \n$\nconfig\n[\nplinker\n][\nprivate_key\n]\n,\n\n\n\n    \n//\n \nconstruct\n \nvalues\n \nwhich\n \nyou\n \npass\n \nto\n \nthe\n \ncomponent\n,\n \nwhich\n \nthe\n \ncomponent\n\n\n    \n//\n  \nwill\n \nuse\n,\n \nfor\n \nRedbeanPHP\n \ncomponent\n \nyou\n \nwould\n \nsend\n \nthe\n \ndatabase\n \nconnection\n\n\n    \n//\n  \ndont\n \nworry\n \nits\n \nAES\n \nencrypted\n.\n \nsee\n:\n \nencryption\n-\nproof\n.\ntxt\n\n\n    \n$\nconfig\n\n\n)\n;\n\n\n\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$iptables-\nsetup([\n    \nbuild_sleep\n =\n 5,\n    // LXD settings *required\n    \nlxd\n =\n [\n        \nbridge\n =\n \nlxdbr0\n,\n        \nip\n =\n \n10.158.250.0/24\n\n    ],\n    // Docker settings *optional\n    \ndocker\n =\n [\n        \nbridge\n =\n \ndocker0\n,\n        \nip\n =\n \n172.17.0.0/16\n\n    ]\n]);\n\n\n\n\n\nCreate\n\n\n$route = [\n    \nlabel\n =\n \nExample\n,\n    \ndomains\n =\n [\n        \nexample.com\n,\n        \nwww.example.com\n\n    ],\n    \nupstreams\n =\n [\n        [\nip\n =\n \n127.0.0.1\n, \nport\n =\n \n80\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n$iptables-\nadd($route);\n\n\n\n\n\nUpdate\n\n\n$route = [\n    \nlabel\n =\n \nExample Changed\n,\n    \ndomains\n =\n [\n        \nexample.com\n,\n        \nwww.example.com\n,\n        \nnew.example.com\n,\n    ],\n    \nupstreams\n =\n [\n        [\nip\n =\n 10.0.0.1\n, \nport\n =\n \n8080\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n// column, value, $data\n$iptables-\nupdate(\nid = ?\n, [1], $route);\n\n\n\n\n\nFetch\n\n\n$iptables-\nfetch(\nroute\n);\n$iptables-\nfetch(\nroute\n, \nid = ?\n, [1]);\n$iptables-\nfetch(\nroute\n, \nname = ?\n, [\nsome-guidV4-value\n])\n\n\n\n\n\nRemove\n\n\n$iptables-\nremove(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nRebuild\n\n\n$iptables-\nrebuild(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nReset\n\n\n// dont remove tasks\n$iptables-\nreset();\n\n// remove tasks\n$iptables-\nreset(true);\n\n\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.", 
            "title": "Iptables"
        }, 
        {
            "location": "/iptables/#plinker-rpc-iptables", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.  WIP: control iptables though rpc", 
            "title": "Plinker-RPC - Iptables"
        }, 
        {
            "location": "/iptables/#installing", 
            "text": "Bring in the project with composer:  {\n     require : {\n         plinker/iptables :  =v0.1 \n    }\n}  Then navigate to  ./vendor/plinker/iptables/scripts  and run  bash install.sh", 
            "title": "::Installing::"
        }, 
        {
            "location": "/iptables/#client", 
            "text": "/**   * Plinker Config   */  $ config   =   [       //   plinker   connection       plinker   =   [           endpoint   =   http://127.0.0.1:88 ,           public_key    =   makeSomethingUp ,           private_key   =   againMakeSomethingUp       ] ,       //   database   connection       database   =   [           dsn        =   sqlite:./.plinker/database.db ,           host       =   ,           name       =   ,           username   =   ,           password   =   ,           freeze     =   false ,           debug      =   false ,       ]  ];  //   init   plinker   endpoint   client  $ iptables   =   new   \\ Plinker \\ Core \\ Client (       //   where   is   the   plinker   server       $ config [ plinker ][ endpoint ] ,       //   component   namespace   to   interface   to       Iptables\\Manager ,       //   keys       $ config [ plinker ][ public_key ] ,       $ config [ plinker ][ private_key ] ,       //   construct   values   which   you   pass   to   the   component ,   which   the   component       //    will   use ,   for   RedbeanPHP   component   you   would   send   the   database   connection       //    dont   worry   its   AES   encrypted .   see :   encryption - proof . txt       $ config  ) ;", 
            "title": "::Client::"
        }, 
        {
            "location": "/iptables/#calls", 
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $iptables- setup([\n     build_sleep  =  5,\n    // LXD settings *required\n     lxd  =  [\n         bridge  =   lxdbr0 ,\n         ip  =   10.158.250.0/24 \n    ],\n    // Docker settings *optional\n     docker  =  [\n         bridge  =   docker0 ,\n         ip  =   172.17.0.0/16 \n    ]\n]);  Create  $route = [\n     label  =   Example ,\n     domains  =  [\n         example.com ,\n         www.example.com \n    ],\n     upstreams  =  [\n        [ ip  =   127.0.0.1 ,  port  =   80 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n$iptables- add($route);  Update  $route = [\n     label  =   Example Changed ,\n     domains  =  [\n         example.com ,\n         www.example.com ,\n         new.example.com ,\n    ],\n     upstreams  =  [\n        [ ip  =  10.0.0.1 ,  port  =   8080 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n// column, value, $data\n$iptables- update( id = ? , [1], $route);  Fetch  $iptables- fetch( route );\n$iptables- fetch( route ,  id = ? , [1]);\n$iptables- fetch( route ,  name = ? , [ some-guidV4-value ])  Remove  $iptables- remove( name = ? , [$route[ name ]]);  Rebuild  $iptables- rebuild( name = ? , [$route[ name ]]);  Reset  // dont remove tasks\n$iptables- reset();\n\n// remove tasks\n$iptables- reset(true);  See the  organisations page  for additional \ncomponents and examples.", 
            "title": "::Calls::"
        }, 
        {
            "location": "/lxc/", 
            "text": "Plinker-RPC - LXC\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nWIP: An older/deprecated component which controls LXC1.0 containers.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/lxc\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\nWIP: To be updated with info on how to use this component, also add the tasks code.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $url to host\n\n\n * @param string $component namespace of class to interface to\n\n\n * @param string $public_key to authenticate on host\n\n\n * @param string $private_key to authenticate on host\n\n\n * @param string $config component construct config\n\n\n */\n\n\n$plink\n \n=\n \nnew\n \nPlinker\\Core\\Client\n(\n\n    \nhttp://example.com\n,\n\n    \nTest\\Demo\n,\n\n    \nusername\n,\n\n    \npassword\n,\n\n    \narray\n(\n\n        \ntime\n \n=\n \ntime\n()\n\n    \n)\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$plink\n-\ntest\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Lxc"
        }, 
        {
            "location": "/lxc/#plinker-rpc-lxc", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  WIP: An older/deprecated component which controls LXC1.0 containers.  Composer  {\n     require : {\n         plinker/core :  =v0.1 ,\n         plinker/lxc :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - LXC"
        }, 
        {
            "location": "/lxc/#making-a-remote-call", 
            "text": "WIP: To be updated with info on how to use this component, also add the tasks code.  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $url to host   * @param string $component namespace of class to interface to   * @param string $public_key to authenticate on host   * @param string $private_key to authenticate on host   * @param string $config component construct config   */  $plink   =   new   Plinker\\Core\\Client ( \n     http://example.com , \n     Test\\Demo , \n     username , \n     password , \n     array ( \n         time   =   time () \n     )  );  echo   pre . print_r ( $plink - test (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/nginx/", 
            "text": "Plinker-RPC - Nginx\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nThe aim of this component is to build web forwards/reverse proxy to LXD/LXC \ncontainers on the host (or external upstreams), not as a \nserver{}\n block configurator.\n\n\nThe component uses nginx as a reverse proxy, it relies on php7-fpm being \ninstalled and will overwrite \n/etc/nginx/nginx.conf\n! So if you already have\nnginx installed then dont use this component as it will most likely break your stuff.\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \nrequire\n: {\n        \nplinker/nginx\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nThen navigate to \n./vendor/plinker/nginx/scripts\n and run \nbash install.sh\n\n\nThe webroot for plinker will be \n/var/www/html\n so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.\n\n\n::Client::\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$\nconfig\n \n=\n \n[\n\n\n    \n//\n \nplinker\n \nconnection\n\n\n    \nplinker\n \n=\n \n[\n\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1:88\n,\n\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n\n    \n]\n,\n\n\n\n    \n//\n \ndatabase\n \nconnection\n\n\n    \ndatabase\n \n=\n \n[\n\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n\n        \nhost\n     \n=\n \n,\n\n\n        \nname\n     \n=\n \n,\n\n\n        \nusername\n \n=\n \n,\n\n\n        \npassword\n \n=\n \n,\n\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n\n    \n]\n\n\n];\n\n\n\n//\n \ninit\n \nplinker\n \nendpoint\n \nclient\n\n\n$\nnginx\n \n=\n \nnew\n \n\\\nPlinker\n\\\nCore\n\\\nClient\n(\n\n\n    \n//\n \nwhere\n \nis\n \nthe\n \nplinker\n \nserver\n\n\n    \n$\nconfig\n[\nplinker\n][\nendpoint\n]\n,\n\n\n\n    \n//\n \ncomponent\n \nnamespace\n \nto\n \ninterface\n \nto\n\n\n    \nNginx\\Manager\n,\n\n\n\n    \n//\n \nkeys\n\n\n    \n$\nconfig\n[\nplinker\n][\npublic_key\n]\n,\n\n\n    \n$\nconfig\n[\nplinker\n][\nprivate_key\n]\n,\n\n\n\n    \n//\n \nconstruct\n \nvalues\n \nwhich\n \nyou\n \npass\n \nto\n \nthe\n \ncomponent\n,\n \nwhich\n \nthe\n \ncomponent\n\n\n    \n//\n  \nwill\n \nuse\n,\n \nfor\n \nRedbeanPHP\n \ncomponent\n \nyou\n \nwould\n \nsend\n \nthe\n \ndatabase\n \nconnection\n\n\n    \n//\n  \ndont\n \nworry\n \nits\n \nAES\n \nencrypted\n.\n \nsee\n:\n \nencryption\n-\nproof\n.\ntxt\n\n\n    \n$\nconfig\n\n\n)\n;\n\n\n\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$nginx-\nsetup([\n    \nbuild_sleep\n =\n 1    \n])\n\n\n\n\n\nCreate\n\n\n$route = [\n    \nlabel\n =\n \nExample\n,\n    \nownDomain\n =\n [\n        [\nname\n =\n \nexample.com\n],\n        [\nname\n =\n \nwww.example.com\n]\n    ],\n    \nownUpstream\n =\n [\n        [\nip\n =\n \n127.0.0.1\n, \nport\n =\n \n80\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n$nginx-\nadd($route);\n\n\n\n\n\nUpdate\n\n\n$route = [\n    \nlabel\n =\n \nExample Changed\n,\n    \nownDomain\n =\n [\n        [\nname\n =\n \nexample.com\n],\n        [\nname\n =\n \nwww.example.com\n],\n        [\nname\n =\n \nnew.example.com\n]\n    ],\n    \nownUpstream\n =\n [\n        [\nip\n =\n 10.0.0.1\n, \nport\n =\n \n8080\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n// column, value, $data\n$nginx-\nupdate(\nid = ?\n, [1], $data);\n\n\n\n\n\nFetch\n\n\n$nginx-\nfetch(\nroute\n);\n$nginx-\nfetch(\nroute\n, \nid = ?\n, [1]);\n$nginx-\nfetch(\nroute\n, \nname = ?\n, [\nsome-guidV4-value\n])\n\n\n\n\n\nRemove\n\n\n$nginx-\nremove(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nRebuild\n\n\n$nginx-\nrebuild(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nReset\n\n\n// dont remove tasks\n$nginx-\nreset();\n\n// remove tasks\n$nginx-\nreset(true);\n\n\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.", 
            "title": "Nginx"
        }, 
        {
            "location": "/nginx/#plinker-rpc-nginx", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.  The aim of this component is to build web forwards/reverse proxy to LXD/LXC \ncontainers on the host (or external upstreams), not as a  server{}  block configurator.  The component uses nginx as a reverse proxy, it relies on php7-fpm being \ninstalled and will overwrite  /etc/nginx/nginx.conf ! So if you already have\nnginx installed then dont use this component as it will most likely break your stuff.", 
            "title": "Plinker-RPC - Nginx"
        }, 
        {
            "location": "/nginx/#installing", 
            "text": "Bring in the project with composer:  {\n     require : {\n         plinker/nginx :  =v0.1 \n    }\n}  Then navigate to  ./vendor/plinker/nginx/scripts  and run  bash install.sh  The webroot for plinker will be  /var/www/html  so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.", 
            "title": "::Installing::"
        }, 
        {
            "location": "/nginx/#client", 
            "text": "/**   * Plinker Config   */  $ config   =   [       //   plinker   connection       plinker   =   [           endpoint   =   http://127.0.0.1:88 ,           public_key    =   makeSomethingUp ,           private_key   =   againMakeSomethingUp       ] ,       //   database   connection       database   =   [           dsn        =   sqlite:./.plinker/database.db ,           host       =   ,           name       =   ,           username   =   ,           password   =   ,           freeze     =   false ,           debug      =   false ,       ]  ];  //   init   plinker   endpoint   client  $ nginx   =   new   \\ Plinker \\ Core \\ Client (       //   where   is   the   plinker   server       $ config [ plinker ][ endpoint ] ,       //   component   namespace   to   interface   to       Nginx\\Manager ,       //   keys       $ config [ plinker ][ public_key ] ,       $ config [ plinker ][ private_key ] ,       //   construct   values   which   you   pass   to   the   component ,   which   the   component       //    will   use ,   for   RedbeanPHP   component   you   would   send   the   database   connection       //    dont   worry   its   AES   encrypted .   see :   encryption - proof . txt       $ config  ) ;", 
            "title": "::Client::"
        }, 
        {
            "location": "/nginx/#calls", 
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $nginx- setup([\n     build_sleep  =  1    \n])  Create  $route = [\n     label  =   Example ,\n     ownDomain  =  [\n        [ name  =   example.com ],\n        [ name  =   www.example.com ]\n    ],\n     ownUpstream  =  [\n        [ ip  =   127.0.0.1 ,  port  =   80 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n$nginx- add($route);  Update  $route = [\n     label  =   Example Changed ,\n     ownDomain  =  [\n        [ name  =   example.com ],\n        [ name  =   www.example.com ],\n        [ name  =   new.example.com ]\n    ],\n     ownUpstream  =  [\n        [ ip  =  10.0.0.1 ,  port  =   8080 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n// column, value, $data\n$nginx- update( id = ? , [1], $data);  Fetch  $nginx- fetch( route );\n$nginx- fetch( route ,  id = ? , [1]);\n$nginx- fetch( route ,  name = ? , [ some-guidV4-value ])  Remove  $nginx- remove( name = ? , [$route[ name ]]);  Rebuild  $nginx- rebuild( name = ? , [$route[ name ]]);  Reset  // dont remove tasks\n$nginx- reset();\n\n// remove tasks\n$nginx- reset(true);  See the  organisations page  for additional \ncomponents and examples.", 
            "title": "::Calls::"
        }, 
        {
            "location": "/redbean/", 
            "text": "Plinker-RPC - RedBeanPHP\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nRedBeanPHP component which will enable you to directly manage databases on remote sites.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/redbean\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/redbean/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// database connection\n\n        \ndatabase\n \n=\n \n[\n\n            \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n            \nhost\n     \n=\n \n,\n\n            \nname\n     \n=\n \n,\n\n            \nusername\n \n=\n \n,\n\n            \npassword\n \n=\n \n,\n\n            \nfreeze\n   \n=\n \nfalse\n,\n\n            \ndebug\n    \n=\n \nfalse\n,\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$rdb\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nRedbean\\Redbean\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct values which you pass to the component\n\n        \n$config\n[\ndatabase\n]\n\n    \n);\n\n\n    \n//..\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Redbean"
        }, 
        {
            "location": "/redbean/#plinker-rpc-redbeanphp", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  RedBeanPHP component which will enable you to directly manage databases on remote sites.  Composer  {\n     require : {\n         plinker/redbean :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - RedBeanPHP"
        }, 
        {
            "location": "/redbean/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/redbean/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // database connection \n         database   =   [ \n             dsn        =   sqlite:./.plinker/database.db , \n             host       =   , \n             name       =   , \n             username   =   , \n             password   =   , \n             freeze     =   false , \n             debug      =   false , \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $rdb   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Redbean\\Redbean , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct values which you pass to the component \n         $config [ database ] \n     ); \n\n     //..  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/system/", 
            "text": "Plinker-RPC - System\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA system component which gives you access to server information.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/system\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $server\n\n\n * @param string $config\n\n\n */\n\n\n$client\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \nhttp://example.com/server.php\n,\n\n    \n[\n\n        \nsecret\n \n=\n \na secret password\n\n    \n]\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$client\n-\nsystem\n-\nmemory_stats\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "System"
        }, 
        {
            "location": "/system/#plinker-rpc-system", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A system component which gives you access to server information.  Composer  {\n     require : {\n         plinker/system :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - System"
        }, 
        {
            "location": "/system/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $server   * @param string $config   */  $client   =   new   \\Plinker\\Core\\Client ( \n     http://example.com/server.php , \n     [ \n         secret   =   a secret password \n     ]  );  echo   pre . print_r ( $client - system - memory_stats (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/tasks/", 
            "text": "Plinker-RPC - Tasks\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nThe tasks component allows you to write code based tasks which are completed by a daemon, \nthis could allow you to create a single interface to control a cluster of servers tasks.\n\n\nWant to see an example project? Check out \nPlinkerUI\n.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/tasks\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nExample source\n\n\nYou should create a file which will be run via cron, for example:\n\n\ncron.php\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/*\n\n\n * The cron job\n\n\n *\n\n\n * @reboot while sleep 1; do cd /var/www/html/examples/tasks \n /usr/bin/php run.php ; done\n\n\n */\n\n\n\nif\n \n(\nphp_sapi_name\n()\n \n!=\n \ncli\n)\n \n{\n\n    \nheader\n(\nHTTP/1.0 403 Forbidden\n);\n\n    \nexit\n(\nCLI script\n);\n\n\n}\n\n\n\n$task\n \n=\n \nnew\n \nPlinker\\Tasks\\Runner\n([\n\n    \ndatabase\n \n=\n \n[\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n        \nhost\n     \n=\n \n,\n\n        \nname\n     \n=\n \n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n,\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n        \ndebug\n    \n=\n \nfalse\n\n    \n],\n\n    \ndebug\n       \n=\n \ntrue\n,\n\n    \nlog\n         \n=\n \ntrue\n,\n\n    \nsleep_time\n  \n=\n \n2\n,\n\n    \ntmp_path\n    \n=\n \n./.plinker\n,\n\n    \nauto_update\n \n=\n \n86400\n\n\n]);\n\n\n\n$task\n-\ndaemon\n(\nQueue\n);\n\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$config\n \n=\n \n[\n\n    \n// plinker connection\n\n    \nplinker\n \n=\n \n[\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/tasks/server.php\n,\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n    \n],\n\n\n    \n// database connection\n\n    \ndatabase\n \n=\n \n[\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n        \nhost\n     \n=\n \n,\n\n        \nname\n     \n=\n \n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n,\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n    \n],\n\n\n    \n// displays output to task runner console\n\n    \ndebug\n \n=\n \ntrue\n,\n\n\n    \n// daemon sleep time\n\n    \nsleep_time\n \n=\n \n1\n,\n\n    \ntmp_path\n   \n=\n \n./.plinker\n\n\n];\n\n\n\n// init plinker client\n\n\n$tasks\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \n// where is the plinker server\n\n    \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n    \n// component namespace to interface to\n\n    \nTasks\\Manager\n,\n\n\n    \n// keys\n\n    \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$config\n[\nplinker\n][\npublic_key\n]),\n\n    \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$config\n[\nplinker\n][\nprivate_key\n]),\n\n\n    \n// construct values which you pass to the component, which the component\n\n    \n//  will use, for RedbeanPHP component you would send the database connection\n\n    \n//  dont worry its AES encrypted. see: encryption-proof.txt\n\n    \n$config\n\n\n);\n\n\n\n/**\n\n\n * Example\n\n\n */\n\n\n\n// create the task\n\n\ntry\n \n{\n\n    \n// create task\n\n    \n$tasks\n-\ncreate\n(\n\n        \n// name\n\n        \nHello World\n,\n\n        \n// source\n\n        \n?php echo \nHello World\n;\n,\n\n        \n// type\n\n        \nphp\n,\n\n        \n// description\n\n        \n...\n,\n\n        \n// default params\n\n        \n[]\n\n    \n);\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nif\n \n(\n$e\n-\ngetMessage\n()\n \n==\n \nUnauthorised\n)\n \n{\n\n        \necho\n \nError: Connected successfully but could not authenticate! Check public and private keys.\n;\n\n    \n}\n \nelse\n \n{\n\n        \necho\n \nError:\n.\nstr_replace\n(\nCould not unserialize response:\n,\n \n,\n \ntrim\n(\nhtmlentities\n(\n$e\n-\ngetMessage\n())));\n\n    \n}\n\n\n}\n\n\n\n//run task now - executed as apache user\n\n\n//print_r($tasks-\nrunNow(\nHello World\n));\n\n\n\n// place task in queue to run\n\n\nprint_r\n(\n$tasks\n-\nrun\n(\nHello World\n,\n \n[\n1\n],\n \n5\n));\n\n\n\n// get task status\n\n\nprint_r\n(\n$tasks\n-\nstatus\n(\nHello World\n));\n\n\n\n// get task run count\n\n\nprint_r\n(\n$tasks\n-\nrunCount\n(\nHello World\n));\n\n\n\n// clear all tasks\n\n\n//$tasks-\nclear();\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Plinker Server\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$plinker\n \n=\n \n[\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n    \n];\n\n\n    \n/**\n\n\n     * Plinker server listener\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_POST\n[\ndata\n])\n \n\n        \nisset\n(\n$_POST\n[\ntoken\n])\n \n\n        \nisset\n(\n$_POST\n[\npublic_key\n])\n\n    \n)\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n//\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$plinker\n[\npublic_key\n]),\n\n            \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$plinker\n[\nprivate_key\n])\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components and examples.", 
            "title": "Tasks"
        }, 
        {
            "location": "/tasks/#plinker-rpc-tasks", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  The tasks component allows you to write code based tasks which are completed by a daemon, \nthis could allow you to create a single interface to control a cluster of servers tasks.  Want to see an example project? Check out  PlinkerUI .  Composer  {\n     require : {\n         plinker/core :  =v0.1 ,\n         plinker/tasks :  =v0.1 \n    }\n}  Example source  You should create a file which will be run via cron, for example:  cron.php  ?php  require   ../../vendor/autoload.php ;  /*   * The cron job   *   * @reboot while sleep 1; do cd /var/www/html/examples/tasks   /usr/bin/php run.php ; done   */  if   ( php_sapi_name ()   !=   cli )   { \n     header ( HTTP/1.0 403 Forbidden ); \n     exit ( CLI script );  }  $task   =   new   Plinker\\Tasks\\Runner ([ \n     database   =   [ \n         dsn        =   sqlite:./.plinker/database.db , \n         host       =   , \n         name       =   , \n         username   =   , \n         password   =   , \n         freeze     =   false , \n         debug      =   false \n     ], \n     debug         =   true , \n     log           =   true , \n     sleep_time    =   2 , \n     tmp_path      =   ./.plinker , \n     auto_update   =   86400  ]);  $task - daemon ( Queue );", 
            "title": "Plinker-RPC - Tasks"
        }, 
        {
            "location": "/tasks/#making-a-remote-call", 
            "text": "?php  require   ../../vendor/autoload.php ;  /**   * Plinker Config   */  $config   =   [ \n     // plinker connection \n     plinker   =   [ \n         endpoint   =   http://127.0.0.1/examples/tasks/server.php , \n         public_key    =   makeSomethingUp , \n         private_key   =   againMakeSomethingUp \n     ], \n\n     // database connection \n     database   =   [ \n         dsn        =   sqlite:./.plinker/database.db , \n         host       =   , \n         name       =   , \n         username   =   , \n         password   =   , \n         freeze     =   false , \n         debug      =   false , \n     ], \n\n     // displays output to task runner console \n     debug   =   true , \n\n     // daemon sleep time \n     sleep_time   =   1 , \n     tmp_path     =   ./.plinker  ];  // init plinker client  $tasks   =   new   \\Plinker\\Core\\Client ( \n     // where is the plinker server \n     $config [ plinker ][ endpoint ], \n\n     // component namespace to interface to \n     Tasks\\Manager , \n\n     // keys \n     hash ( sha256 ,   gmdate ( h ) . $config [ plinker ][ public_key ]), \n     hash ( sha256 ,   gmdate ( h ) . $config [ plinker ][ private_key ]), \n\n     // construct values which you pass to the component, which the component \n     //  will use, for RedbeanPHP component you would send the database connection \n     //  dont worry its AES encrypted. see: encryption-proof.txt \n     $config  );  /**   * Example   */  // create the task  try   { \n     // create task \n     $tasks - create ( \n         // name \n         Hello World , \n         // source \n         ?php echo  Hello World ; , \n         // type \n         php , \n         // description \n         ... , \n         // default params \n         [] \n     );  }   catch   ( \\Exception   $e )   { \n     if   ( $e - getMessage ()   ==   Unauthorised )   { \n         echo   Error: Connected successfully but could not authenticate! Check public and private keys. ; \n     }   else   { \n         echo   Error: . str_replace ( Could not unserialize response: ,   ,   trim ( htmlentities ( $e - getMessage ()))); \n     }  }  //run task now - executed as apache user  //print_r($tasks- runNow( Hello World ));  // place task in queue to run  print_r ( $tasks - run ( Hello World ,   [ 1 ],   5 ));  // get task status  print_r ( $tasks - status ( Hello World ));  // get task run count  print_r ( $tasks - runCount ( Hello World ));  // clear all tasks  //$tasks- clear();   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Plinker Server   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Plinker Config       */ \n     $plinker   =   [ \n         public_key    =   makeSomethingUp , \n         private_key   =   againMakeSomethingUp \n     ]; \n\n     /**       * Plinker server listener       */ \n     if   ( isset ( $_POST [ data ])   \n         isset ( $_POST [ token ])   \n         isset ( $_POST [ public_key ]) \n     )   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         // \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             hash ( sha256 ,   gmdate ( h ) . $plinker [ public_key ]), \n             hash ( sha256 ,   gmdate ( h ) . $plinker [ private_key ]) \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components and examples.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/test/", 
            "text": "Plinker-RPC - Test/Demo\n\n\nPlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA Test component which simply returns back what you sent, for testing/example purposes.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/test\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $url to host\n\n\n * @param string $component namespace of class to interface to\n\n\n * @param string $public_key to authenticate on host\n\n\n * @param string $private_key to authenticate on host\n\n\n * @param string $config component construct config\n\n\n */\n\n\n$plink\n \n=\n \nnew\n \nPlinker\\Core\\Client\n(\n\n    \nhttp://example.com\n,\n\n    \nTest\\Demo\n,\n\n    \nusername\n,\n\n    \npassword\n,\n\n    \narray\n(\n\n        \ntime\n \n=\n \ntime\n()\n\n    \n)\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$plink\n-\ntest\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Test"
        }, 
        {
            "location": "/test/#plinker-rpc-testdemo", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A Test component which simply returns back what you sent, for testing/example purposes.  Composer  {\n     require : {\n         plinker/core :  =v0.1 ,\n         plinker/test :  =v0.1 \n    }\n}", 
            "title": "Plinker-RPC - Test/Demo"
        }, 
        {
            "location": "/test/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $url to host   * @param string $component namespace of class to interface to   * @param string $public_key to authenticate on host   * @param string $private_key to authenticate on host   * @param string $config component construct config   */  $plink   =   new   Plinker\\Core\\Client ( \n     http://example.com , \n     Test\\Demo , \n     username , \n     password , \n     array ( \n         time   =   time () \n     )  );  echo   pre . print_r ( $plink - test (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }
    ]
}