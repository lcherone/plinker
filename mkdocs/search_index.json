{
    "docs": [
        {
            "location": "/",
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute generic PHP \ncomponents on remote systems, while maintaining the feel of a local method call.\n\n\nInstall\n\n\nEach component is in a composer package.\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\nVersion\n\n\n\n\n\n\n\n\n\n\ncore\n\n\nRequired base component which contains the client and server.\n\n\n\n\n\n\n\n\n\n\n*Some components require further steps.\n\n\nDevelopment repository\n\n\nIf you would like to contribute then use the \ndevelopment repository\n.\n\n\nThe repository is used to develop the entire project, to make it easy to work on many parts at the same time without forgetting what was done,\nit also contains bash scripts which will commit and do semantic versioning for each sub component and build this documentation.\n\n\nInstall\n\n\n\n\ngit clone git@github.com:plinker-rpc/development.git .\n\n\ncomposer install\n\n\n\n\nCommitting changes:\n\n\n\n\n./php-cs-fixer fix ./vendor/plinker --verbose --rules=@PSR2 --dry-run --diff\n\n\nbash ./commit.sh \"An informative commit message\"\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed here.",
            "title": "Home"
        },
        {
            "location": "/#install",
            "text": "Each component is in a composer package.     Component  Description  Version      core  Required base component which contains the client and server.      *Some components require further steps.",
            "title": "Install"
        },
        {
            "location": "/#development-repository",
            "text": "If you would like to contribute then use the  development repository .  The repository is used to develop the entire project, to make it easy to work on many parts at the same time without forgetting what was done,\nit also contains bash scripts which will commit and do semantic versioning for each sub component and build this documentation.",
            "title": "Development repository"
        },
        {
            "location": "/#install_1",
            "text": "git clone git@github.com:plinker-rpc/development.git .  composer install   Committing changes:   ./php-cs-fixer fix ./vendor/plinker --verbose --rules=@PSR2 --dry-run --diff  bash ./commit.sh \"An informative commit message\"",
            "title": "Install"
        },
        {
            "location": "/#development-encouragement",
            "text": "If you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.",
            "title": "Development Encouragement"
        },
        {
            "location": "/#sponsors",
            "text": "Get your company or name listed here.",
            "title": "Sponsors"
        },
        {
            "location": "/asterisk/",
            "text": "Plinker-RPC - Asterisk\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nAn Asterisk component which hooks into the Asterisk Management Interface on remote systems.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/asterisk\": \">=v0.1\"\n    }\n}\n\n\n\nMaking a remote call.\n\n\nWIP: To be updated with info on how to use this component, also add the tasks code.\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';\n\n\n\nthen the server part...\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Asterisk"
        },
        {
            "location": "/asterisk/#plinker-rpc-asterisk",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  An Asterisk component which hooks into the Asterisk Management Interface on remote systems.  Composer  {\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/asterisk\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - Asterisk"
        },
        {
            "location": "/asterisk/#making-a-remote-call",
            "text": "WIP: To be updated with info on how to use this component, also add the tasks code.  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';  then the server part...  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}  See the  organisations page  for additional components.",
            "title": "Making a remote call."
        },
        {
            "location": "/base91/",
            "text": "Plinker-RPC - Base91\n\n\nA core component, which base91 encodes the payload, you do not need to include it as its included with core.\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Base91"
        },
        {
            "location": "/base91/#plinker-rpc-base91",
            "text": "A core component, which base91 encodes the payload, you do not need to include it as its included with core.  See the  organisations page  for additional components.",
            "title": "Plinker-RPC - Base91"
        },
        {
            "location": "/core/",
            "text": "PlinkerRPC - Core\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute generic PHP components on remote systems, while maintaining the feel of a local method call.\n\n\nNew changes in version 3 include:\n\n\n\n\nNow compaible with \nPHP extension\n.\n\n\nBuilt-in core components and info method added so components can be discovered.\n\n\nOnly one client instance is now needed, made use of __get() to dynamically set component.\n\n\nUser defined components/classes, so you can call your own code.\n\n\nBoth request and response is encrypted and signed.\n\n\n\n\nInstall\n\n\nRequire this package with composer using the following command:\n\n\n$ composer require plinker/core\n\n\n\n\nAdditional Setup\n\n\nThis component does not require any additional setup.\n\n\nClient\n\n\nCreating a client instance is done as follows:\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $server - URL to server listener.\n * @param string $config - server secret, and/or a additional component data\n */\n$client = new \\Plinker\\Core\\Client(\n    'http://example.com/server.php',\n    [\n        'secret' => 'a secret password',\n    ]\n);\n\n\n\nServer\n\n\nCreating a server listener is done as follows:\n\n\nOptional features:\n\n\n\n\nSet a secret, which all clients will require. \n\n\nLock down to specific client IP addresses for addtional security.\n\n\nDefine your own classes in the \nclasses\n array then access like above \n$client->class->method()\n, which can interface out of scope components or composer packages.\n\n\nDefine addtional key values for database connections etc, or you could pass the parameters through the client connection.\n\n\n\n\n\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker server.\n */\nif (isset($_SERVER['HTTP_PLINKER'])) {\n    // init plinker server\n    echo (new \\Plinker\\Server([\n        'secret' => 'a secret password',\n        'allowed_ips' => [\n            '127.0.0.1'\n        ],\n        'classes' => [\n            'test' => [\n                // path to file\n                'classes/test.php',\n                // addtional key/values\n                [\n                    'key' => 'value'\n                ]\n            ],\n            // you can use namespaced classes\n            'Foo\\\\Demo' => [\n                // path to file\n                'some_class/demo.php',\n                // addtional key/values\n                [\n                    'key' => 'value'\n                ]\n            ],\n            // ...\n        ]\n    ]))->listen();\n}\n\n\n\nMethods\n\n\nOnce setup, you call the class though its namespace to its method.\n\n\nInfo\n\n\nThe info method returns defined endpoint methods and their parameters.\n\n\nCall\n\n\n$result = $client->info();\n\n\n\n\nResponse\n\n\nArray\n(\n    [class] => Array\n        (\n            [Foo\\Demo] => Array\n                (\n                    [config] => Array\n                        (\n                            [key] => value\n                        )\n\n                    [methods] => Array\n                        (\n                            [config] => Array\n                                (\n                                )\n\n                            [this] => Array\n                                (\n                                )\n\n                            [test] => Array\n                                (\n                                    [0] => x\n                                    [1] => y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)\n\n\n\n\nTesting\n\n\n$ composer test\n\n\n\n\nContributing\n\n\nPlease see \nCONTRIBUTING\n for details.\n\n\nSecurity\n\n\nIf you discover any security related issues, please contact me via \nhttps://cherone.co.uk\n instead of using the issue tracker.\n\n\nCredits\n\n\n\n\nLawrence Cherone\n\n\nAll Contributors\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed here.\n\n\nLicense\n\n\nThe MIT License (MIT). Please see \nLicense File\n for more information.\n\n\nSee \norganisations page\n for additional components.",
            "title": "Core"
        },
        {
            "location": "/core/#plinkerrpc-core",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute generic PHP components on remote systems, while maintaining the feel of a local method call.  New changes in version 3 include:   Now compaible with  PHP extension .  Built-in core components and info method added so components can be discovered.  Only one client instance is now needed, made use of __get() to dynamically set component.  User defined components/classes, so you can call your own code.  Both request and response is encrypted and signed.",
            "title": "PlinkerRPC - Core"
        },
        {
            "location": "/core/#install",
            "text": "Require this package with composer using the following command:  $ composer require plinker/core",
            "title": "Install"
        },
        {
            "location": "/core/#additional-setup",
            "text": "This component does not require any additional setup.",
            "title": "Additional Setup"
        },
        {
            "location": "/core/#client",
            "text": "Creating a client instance is done as follows:  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $server - URL to server listener.\n * @param string $config - server secret, and/or a additional component data\n */\n$client = new \\Plinker\\Core\\Client(\n    'http://example.com/server.php',\n    [\n        'secret' => 'a secret password',\n    ]\n);",
            "title": "Client"
        },
        {
            "location": "/core/#server",
            "text": "Creating a server listener is done as follows:  Optional features:   Set a secret, which all clients will require.   Lock down to specific client IP addresses for addtional security.  Define your own classes in the  classes  array then access like above  $client->class->method() , which can interface out of scope components or composer packages.  Define addtional key values for database connections etc, or you could pass the parameters through the client connection.    <?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker server.\n */\nif (isset($_SERVER['HTTP_PLINKER'])) {\n    // init plinker server\n    echo (new \\Plinker\\Server([\n        'secret' => 'a secret password',\n        'allowed_ips' => [\n            '127.0.0.1'\n        ],\n        'classes' => [\n            'test' => [\n                // path to file\n                'classes/test.php',\n                // addtional key/values\n                [\n                    'key' => 'value'\n                ]\n            ],\n            // you can use namespaced classes\n            'Foo\\\\Demo' => [\n                // path to file\n                'some_class/demo.php',\n                // addtional key/values\n                [\n                    'key' => 'value'\n                ]\n            ],\n            // ...\n        ]\n    ]))->listen();\n}",
            "title": "Server"
        },
        {
            "location": "/core/#methods",
            "text": "Once setup, you call the class though its namespace to its method.",
            "title": "Methods"
        },
        {
            "location": "/core/#info",
            "text": "The info method returns defined endpoint methods and their parameters.  Call  $result = $client->info();  Response  Array\n(\n    [class] => Array\n        (\n            [Foo\\Demo] => Array\n                (\n                    [config] => Array\n                        (\n                            [key] => value\n                        )\n\n                    [methods] => Array\n                        (\n                            [config] => Array\n                                (\n                                )\n\n                            [this] => Array\n                                (\n                                )\n\n                            [test] => Array\n                                (\n                                    [0] => x\n                                    [1] => y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)",
            "title": "Info"
        },
        {
            "location": "/core/#testing",
            "text": "$ composer test",
            "title": "Testing"
        },
        {
            "location": "/core/#contributing",
            "text": "Please see  CONTRIBUTING  for details.",
            "title": "Contributing"
        },
        {
            "location": "/core/#security",
            "text": "If you discover any security related issues, please contact me via  https://cherone.co.uk  instead of using the issue tracker.",
            "title": "Security"
        },
        {
            "location": "/core/#credits",
            "text": "Lawrence Cherone  All Contributors",
            "title": "Credits"
        },
        {
            "location": "/core/#development-encouragement",
            "text": "If you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.",
            "title": "Development Encouragement"
        },
        {
            "location": "/core/#sponsors",
            "text": "Get your company or name listed here.",
            "title": "Sponsors"
        },
        {
            "location": "/core/#license",
            "text": "The MIT License (MIT). Please see  License File  for more information.  See  organisations page  for additional components.",
            "title": "License"
        },
        {
            "location": "/cron/",
            "text": "Plinker-RPC - CRON\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA cron component which allows you to read and control cron tasks.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/cron\": \">=v0.1\"\n    }\n}\n\n\n\nMaking remote calls.\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/cron/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // optional config\n        'config' => [\n            'journal' => './crontab.journal',\n            'apply'   => false\n        ]\n    ];\n\n    // init plinker endpoint client\n    $cron = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Cron\\Manager',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct array which you pass to the component\n        $config['config']\n    );\n\n    // get crontab as-is\n    echo '<h2>$cron->crontab()</h2>';\n    echo '<pre>'.$cron->crontab().'</pre>';\n\n    // create a crontask\n    echo '<h2>$cron->create(\\'My Cron Task\\', \\'* * * * * cd ~\\')</h2>';\n    echo '<pre>'.$cron->create('My Cron Task', '* * * * * cd ~').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // update cron task\n    echo '<h2>$cron->update(\\'My Cron Task\\', \\'0 * * * * cd ~\\')</h2>';\n    echo '<pre>'.$cron->update('My Cron Task', '0 * * * * cd ~').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // delete cron task\n    echo '<h2>$cron->delete(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->delete('My Cron Task').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // drop cron task\n    echo '<h2>$cron->drop()</h2>';\n    echo '<pre>'.$cron->drop().'</pre>';\n\n    // get crontab as-is\n    echo '<h2>$cron->crontab()</h2>';\n    echo '<pre>'.$cron->crontab().'</pre>';\n\n    // apply crontab\n    echo '<h2>$cron->apply()</h2>';\n    echo '<pre>'.$cron->apply().'</pre>';\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}\n\n\n\nthen the server part...\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Its POST..\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Its Plinker!\n     */\n    if (isset($_SERVER['HTTP_PLINKER'])) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        /**\n         * Define Plinker Config\n         */\n        $plinker = [\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp',\n            // optional config\n            /*'config' => [\n                // allowed ips, restrict access by ip\n                'allowed_ips' => [\n                    '127.0.0.1'\n                ]\n            ]*/\n        ];\n\n        // init plinker server\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            $plinker['public_key'],\n            $plinker['private_key'],\n            (array) @$plinker['config']\n        );\n\n        exit($server->execute());\n    }\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Cron"
        },
        {
            "location": "/cron/#plinker-rpc-cron",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A cron component which allows you to read and control cron tasks.  Composer  {\n    \"require\": {\n        \"plinker/cron\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - CRON"
        },
        {
            "location": "/cron/#making-remote-calls",
            "text": "<?php\nrequire '../../vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/cron/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // optional config\n        'config' => [\n            'journal' => './crontab.journal',\n            'apply'   => false\n        ]\n    ];\n\n    // init plinker endpoint client\n    $cron = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Cron\\Manager',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct array which you pass to the component\n        $config['config']\n    );\n\n    // get crontab as-is\n    echo '<h2>$cron->crontab()</h2>';\n    echo '<pre>'.$cron->crontab().'</pre>';\n\n    // create a crontask\n    echo '<h2>$cron->create(\\'My Cron Task\\', \\'* * * * * cd ~\\')</h2>';\n    echo '<pre>'.$cron->create('My Cron Task', '* * * * * cd ~').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // update cron task\n    echo '<h2>$cron->update(\\'My Cron Task\\', \\'0 * * * * cd ~\\')</h2>';\n    echo '<pre>'.$cron->update('My Cron Task', '0 * * * * cd ~').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // delete cron task\n    echo '<h2>$cron->delete(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->delete('My Cron Task').'</pre>';\n\n    // get cron task\n    echo '<h2>$cron->get(\\'My Cron Task\\')</h2>';\n    echo '<pre>'.$cron->get('My Cron Task').'</pre>';\n\n    // drop cron task\n    echo '<h2>$cron->drop()</h2>';\n    echo '<pre>'.$cron->drop().'</pre>';\n\n    // get crontab as-is\n    echo '<h2>$cron->crontab()</h2>';\n    echo '<pre>'.$cron->crontab().'</pre>';\n\n    // apply crontab\n    echo '<h2>$cron->apply()</h2>';\n    echo '<pre>'.$cron->apply().'</pre>';\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}  then the server part...  <?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Its POST..\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Its Plinker!\n     */\n    if (isset($_SERVER['HTTP_PLINKER'])) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        /**\n         * Define Plinker Config\n         */\n        $plinker = [\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp',\n            // optional config\n            /*'config' => [\n                // allowed ips, restrict access by ip\n                'allowed_ips' => [\n                    '127.0.0.1'\n                ]\n            ]*/\n        ];\n\n        // init plinker server\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            $plinker['public_key'],\n            $plinker['private_key'],\n            (array) @$plinker['config']\n        );\n\n        exit($server->execute());\n    }\n}  See the  organisations page  for additional components.",
            "title": "Making remote calls."
        },
        {
            "location": "/files/",
            "text": "Plinker-RPC - Files\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA files component which allows you to read and write files.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/files\": \">=v0.1\"\n    }\n}\n\n\n\nMaking remote calls.\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/cron/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // optional config\n        'config' => [\n            'journal' => './crontab.journal',\n            'apply'   => false\n        ]\n    ];\n\n    // init plinker endpoint client\n    $cron = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Files\\Manager',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct array which you pass to the component\n        $config['config']\n    );\n\n    // todo!\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}\n\n\n\nthen the server part...\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Its POST..\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Its Plinker!\n     */\n    if (isset($_SERVER['HTTP_PLINKER'])) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        /**\n         * Define Plinker Config\n         */\n        $plinker = [\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp',\n            // optional config\n            /*'config' => [\n                // allowed ips, restrict access by ip\n                'allowed_ips' => [\n                    '127.0.0.1'\n                ]\n            ]*/\n        ];\n\n        // init plinker server\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            $plinker['public_key'],\n            $plinker['private_key'],\n            (array) @$plinker['config']\n        );\n\n        exit($server->execute());\n    }\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Files"
        },
        {
            "location": "/files/#plinker-rpc-files",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A files component which allows you to read and write files.  Composer  {\n    \"require\": {\n        \"plinker/files\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - Files"
        },
        {
            "location": "/files/#making-remote-calls",
            "text": "<?php\nrequire '../../vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/cron/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // optional config\n        'config' => [\n            'journal' => './crontab.journal',\n            'apply'   => false\n        ]\n    ];\n\n    // init plinker endpoint client\n    $cron = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Files\\Manager',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct array which you pass to the component\n        $config['config']\n    );\n\n    // todo!\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}  then the server part...  <?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Its POST..\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Its Plinker!\n     */\n    if (isset($_SERVER['HTTP_PLINKER'])) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        /**\n         * Define Plinker Config\n         */\n        $plinker = [\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp',\n            // optional config\n            /*'config' => [\n                // allowed ips, restrict access by ip\n                'allowed_ips' => [\n                    '127.0.0.1'\n                ]\n            ]*/\n        ];\n\n        // init plinker server\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            $plinker['public_key'],\n            $plinker['private_key'],\n            (array) @$plinker['config']\n        );\n\n        exit($server->execute());\n    }\n}  See the  organisations page  for additional components.",
            "title": "Making remote calls."
        },
        {
            "location": "/iptables/",
            "text": "Plinker-RPC - Iptables\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nWIP: control iptables though rpc\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \"require\": {\n        \"plinker/iptables\": \">=v0.1\"\n    }\n}\n\n\n\nThen navigate to \n./vendor/plinker/iptables/scripts\n and run \nbash install.sh\n\n\n::Client::\n\n\n/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1:88',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ]\n];\n\n// init plinker endpoint client\n$iptables = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Iptables\\Manager',\n\n    // keys\n    $config['plinker']['public_key'],\n    $config['plinker']['private_key'],\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$iptables->setup([\n    'build_sleep' => 5,\n    // LXD settings *required\n    'lxd' => [\n        'bridge' => 'lxdbr0',\n        'ip' => '10.158.250.0/24'\n    ],\n    // Docker settings *optional\n    'docker' => [\n        'bridge' => 'docker0',\n        'ip' => '172.17.0.0/16'\n    ]\n]);\n\n\n\nCreate\n\n\n$route = [\n    'label' => 'Example',\n    'domains' => [\n        'example.com',\n        'www.example.com'\n    ],\n    'upstreams' => [\n        ['ip' => '127.0.0.1', 'port' => '80']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n$iptables->add($route);\n\n\n\nUpdate\n\n\n$route = [\n    'label' => 'Example Changed',\n    'domains' => [\n        'example.com',\n        'www.example.com',\n        'new.example.com',\n    ],\n    'upstreams' => [\n        ['ip' => 10.0.0.1', 'port' => '8080']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n// column, value, $data\n$iptables->update('id = ?', [1], $route);\n\n\n\nFetch\n\n\n$iptables->fetch('route');\n$iptables->fetch('route', 'id = ?', [1]);\n$iptables->fetch('route', 'name = ?', ['some-guidV4-value'])\n\n\n\nRemove\n\n\n$iptables->remove('name = ?', [$route['name']]);\n\n\n\nRebuild\n\n\n$iptables->rebuild('name = ?', [$route['name']]);\n\n\n\nReset\n\n\n// dont remove tasks\n$iptables->reset();\n\n// remove tasks\n$iptables->reset(true);\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.",
            "title": "Iptables"
        },
        {
            "location": "/iptables/#plinker-rpc-iptables",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.  WIP: control iptables though rpc",
            "title": "Plinker-RPC - Iptables"
        },
        {
            "location": "/iptables/#installing",
            "text": "Bring in the project with composer:  {\n    \"require\": {\n        \"plinker/iptables\": \">=v0.1\"\n    }\n}  Then navigate to  ./vendor/plinker/iptables/scripts  and run  bash install.sh",
            "title": "::Installing::"
        },
        {
            "location": "/iptables/#client",
            "text": "/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1:88',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ]\n];\n\n// init plinker endpoint client\n$iptables = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Iptables\\Manager',\n\n    // keys\n    $config['plinker']['public_key'],\n    $config['plinker']['private_key'],\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);",
            "title": "::Client::"
        },
        {
            "location": "/iptables/#calls",
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $iptables->setup([\n    'build_sleep' => 5,\n    // LXD settings *required\n    'lxd' => [\n        'bridge' => 'lxdbr0',\n        'ip' => '10.158.250.0/24'\n    ],\n    // Docker settings *optional\n    'docker' => [\n        'bridge' => 'docker0',\n        'ip' => '172.17.0.0/16'\n    ]\n]);  Create  $route = [\n    'label' => 'Example',\n    'domains' => [\n        'example.com',\n        'www.example.com'\n    ],\n    'upstreams' => [\n        ['ip' => '127.0.0.1', 'port' => '80']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n$iptables->add($route);  Update  $route = [\n    'label' => 'Example Changed',\n    'domains' => [\n        'example.com',\n        'www.example.com',\n        'new.example.com',\n    ],\n    'upstreams' => [\n        ['ip' => 10.0.0.1', 'port' => '8080']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n// column, value, $data\n$iptables->update('id = ?', [1], $route);  Fetch  $iptables->fetch('route');\n$iptables->fetch('route', 'id = ?', [1]);\n$iptables->fetch('route', 'name = ?', ['some-guidV4-value'])  Remove  $iptables->remove('name = ?', [$route['name']]);  Rebuild  $iptables->rebuild('name = ?', [$route['name']]);  Reset  // dont remove tasks\n$iptables->reset();\n\n// remove tasks\n$iptables->reset(true);  See the  organisations page  for additional \ncomponents and examples.",
            "title": "::Calls::"
        },
        {
            "location": "/lxc/",
            "text": "Plinker-RPC - LXC\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nWIP: An older/deprecated component which controls LXC1.0 containers.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/lxc\": \">=v0.1\"\n    }\n}\n\n\n\nMaking a remote call.\n\n\nWIP: To be updated with info on how to use this component, also add the tasks code.\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';\n\n\n\nthen the server part...\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Lxc"
        },
        {
            "location": "/lxc/#plinker-rpc-lxc",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  WIP: An older/deprecated component which controls LXC1.0 containers.  Composer  {\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/lxc\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - LXC"
        },
        {
            "location": "/lxc/#making-a-remote-call",
            "text": "WIP: To be updated with info on how to use this component, also add the tasks code.  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';  then the server part...  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}  See the  organisations page  for additional components.",
            "title": "Making a remote call."
        },
        {
            "location": "/nginx/",
            "text": "Plinker-RPC - Nginx\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nThe aim of this component is to build web forwards/reverse proxy to LXD/LXC \ncontainers on the host (or external upstreams), not as a \nserver{}\n block configurator.\n\n\nThe component uses nginx as a reverse proxy, it relies on php7-fpm being \ninstalled and will overwrite \n/etc/nginx/nginx.conf\n! So if you already have\nnginx installed then dont use this component as it will most likely break your stuff.\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \"require\": {\n        \"plinker/nginx\": \">=v0.1\"\n    }\n}\n\n\n\nThen navigate to \n./vendor/plinker/nginx/scripts\n and run \nbash install.sh\n\n\nThe webroot for plinker will be \n/var/www/html\n so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.\n\n\n::Client::\n\n\n/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1:88',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ]\n];\n\n// init plinker endpoint client\n$nginx = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Nginx\\Manager',\n\n    // keys\n    $config['plinker']['public_key'],\n    $config['plinker']['private_key'],\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$nginx->setup([\n    'build_sleep' => 1    \n])\n\n\n\nCreate\n\n\n$route = [\n    'label' => 'Example',\n    'ownDomain' => [\n        ['name' => 'example.com'],\n        ['name' => 'www.example.com']\n    ],\n    'ownUpstream' => [\n        ['ip' => '127.0.0.1', 'port' => '80']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n$nginx->add($route);\n\n\n\nUpdate\n\n\n$route = [\n    'label' => 'Example Changed',\n    'ownDomain' => [\n        ['name' => 'example.com'],\n        ['name' => 'www.example.com'],\n        ['name' => 'new.example.com']\n    ],\n    'ownUpstream' => [\n        ['ip' => 10.0.0.1', 'port' => '8080']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n// column, value, $data\n$nginx->update('id = ?', [1], $data);\n\n\n\nFetch\n\n\n$nginx->fetch('route');\n$nginx->fetch('route', 'id = ?', [1]);\n$nginx->fetch('route', 'name = ?', ['some-guidV4-value'])\n\n\n\nRemove\n\n\n$nginx->remove('name = ?', [$route['name']]);\n\n\n\nRebuild\n\n\n$nginx->rebuild('name = ?', [$route['name']]);\n\n\n\nReset\n\n\n// dont remove tasks\n$nginx->reset();\n\n// remove tasks\n$nginx->reset(true);\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.",
            "title": "Nginx"
        },
        {
            "location": "/nginx/#plinker-rpc-nginx",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.  The aim of this component is to build web forwards/reverse proxy to LXD/LXC \ncontainers on the host (or external upstreams), not as a  server{}  block configurator.  The component uses nginx as a reverse proxy, it relies on php7-fpm being \ninstalled and will overwrite  /etc/nginx/nginx.conf ! So if you already have\nnginx installed then dont use this component as it will most likely break your stuff.",
            "title": "Plinker-RPC - Nginx"
        },
        {
            "location": "/nginx/#installing",
            "text": "Bring in the project with composer:  {\n    \"require\": {\n        \"plinker/nginx\": \">=v0.1\"\n    }\n}  Then navigate to  ./vendor/plinker/nginx/scripts  and run  bash install.sh  The webroot for plinker will be  /var/www/html  so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.",
            "title": "::Installing::"
        },
        {
            "location": "/nginx/#client",
            "text": "/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1:88',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ]\n];\n\n// init plinker endpoint client\n$nginx = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Nginx\\Manager',\n\n    // keys\n    $config['plinker']['public_key'],\n    $config['plinker']['private_key'],\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);",
            "title": "::Client::"
        },
        {
            "location": "/nginx/#calls",
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $nginx->setup([\n    'build_sleep' => 1    \n])  Create  $route = [\n    'label' => 'Example',\n    'ownDomain' => [\n        ['name' => 'example.com'],\n        ['name' => 'www.example.com']\n    ],\n    'ownUpstream' => [\n        ['ip' => '127.0.0.1', 'port' => '80']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n$nginx->add($route);  Update  $route = [\n    'label' => 'Example Changed',\n    'ownDomain' => [\n        ['name' => 'example.com'],\n        ['name' => 'www.example.com'],\n        ['name' => 'new.example.com']\n    ],\n    'ownUpstream' => [\n        ['ip' => 10.0.0.1', 'port' => '8080']\n    ],\n    'letsencrypt' => 0,\n    'enabled' => 1\n];\n// column, value, $data\n$nginx->update('id = ?', [1], $data);  Fetch  $nginx->fetch('route');\n$nginx->fetch('route', 'id = ?', [1]);\n$nginx->fetch('route', 'name = ?', ['some-guidV4-value'])  Remove  $nginx->remove('name = ?', [$route['name']]);  Rebuild  $nginx->rebuild('name = ?', [$route['name']]);  Reset  // dont remove tasks\n$nginx->reset();\n\n// remove tasks\n$nginx->reset(true);  See the  organisations page  for additional \ncomponents and examples.",
            "title": "::Calls::"
        },
        {
            "location": "/redbean/",
            "text": "Plinker-RPC - RedBeanPHP\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nRedBeanPHP component which will enable you to directly manage databases on remote sites.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/redbean\": \">=v0.1\"\n    }\n}\n\n\n\nMaking a remote call.\n\n\n<?php\nrequire 'vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/redbean/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // database connection\n        'database' => [\n            'dsn'      => 'sqlite:./.plinker/database.db',\n            'host'     => '',\n            'name'     => '',\n            'username' => '',\n            'password' => '',\n            'freeze'   => false,\n            'debug'    => false,\n        ]\n    ];\n\n    // init plinker endpoint client\n    $rdb = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Redbean\\Redbean',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct values which you pass to the component\n        $config['database']\n    );\n\n    //..\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}\n\n\n\nthen the server part...\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Redbean"
        },
        {
            "location": "/redbean/#plinker-rpc-redbeanphp",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  RedBeanPHP component which will enable you to directly manage databases on remote sites.  Composer  {\n    \"require\": {\n        \"plinker/redbean\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - RedBeanPHP"
        },
        {
            "location": "/redbean/#making-a-remote-call",
            "text": "<?php\nrequire 'vendor/autoload.php';\n\ntry {\n\n    /**\n     * Plinker Config\n     */\n    $config = [\n        // plinker connection | using tasks as to write in the correct .sqlite file\n        'plinker' => [\n            'endpoint' => 'http://127.0.0.1/examples/redbean/server.php',\n            'public_key'  => 'makeSomethingUp',\n            'private_key' => 'againMakeSomethingUp'\n        ],\n\n        // database connection\n        'database' => [\n            'dsn'      => 'sqlite:./.plinker/database.db',\n            'host'     => '',\n            'name'     => '',\n            'username' => '',\n            'password' => '',\n            'freeze'   => false,\n            'debug'    => false,\n        ]\n    ];\n\n    // init plinker endpoint client\n    $rdb = new \\Plinker\\Core\\Client(\n        // where is the plinker server\n        $config['plinker']['endpoint'],\n\n        // component namespace to interface to\n        'Redbean\\Redbean',\n\n        // keys\n        $config['plinker']['public_key'],\n        $config['plinker']['private_key'],\n\n        // construct values which you pass to the component\n        $config['database']\n    );\n\n    //..\n\n} catch (\\Exception $e) {\n    exit(get_class($e).': '.$e->getMessage());\n}  then the server part...  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}  See the  organisations page  for additional components.",
            "title": "Making a remote call."
        },
        {
            "location": "/system/",
            "text": "Plinker-RPC - System\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA system component which gives you access to server information.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/system\": \">=v0.1\"\n    }\n}\n\n\n\nMaking a remote call.\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $server\n * @param string $config\n */\n$client = new \\Plinker\\Core\\Client(\n    'http://example.com/server.php',\n    [\n        'secret' => 'a secret password'\n    ]\n);\necho '<pre>'.print_r($client->system->memory_stats(), true).'</pre>';\n\n\n\nthen the server part...\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "System"
        },
        {
            "location": "/system/#plinker-rpc-system",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A system component which gives you access to server information.  Composer  {\n    \"require\": {\n        \"plinker/system\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - System"
        },
        {
            "location": "/system/#making-a-remote-call",
            "text": "<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $server\n * @param string $config\n */\n$client = new \\Plinker\\Core\\Client(\n    'http://example.com/server.php',\n    [\n        'secret' => 'a secret password'\n    ]\n);\necho '<pre>'.print_r($client->system->memory_stats(), true).'</pre>';  then the server part...  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}  See the  organisations page  for additional components.",
            "title": "Making a remote call."
        },
        {
            "location": "/tasks/",
            "text": "Plinker-RPC - Tasks\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nThe tasks component allows you to write code based tasks which are completed by a daemon, \nthis could allow you to create a single interface to control a cluster of servers tasks.\n\n\nWant to see an example project? Check out \nPlinkerUI\n.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/tasks\": \">=v0.1\"\n    }\n}\n\n\n\nExample source\n\n\nYou should create a file which will be run via cron, for example:\n\n\ncron.php\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\n/*\n * The cron job\n *\n * @reboot while sleep 1; do cd /var/www/html/examples/tasks && /usr/bin/php run.php ; done\n */\n\nif (php_sapi_name() != 'cli') {\n    header('HTTP/1.0 403 Forbidden');\n    exit('CLI script');\n}\n\n$task = new Plinker\\Tasks\\Runner([\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false\n    ],\n    'debug'       => true,\n    'log'         => true,\n    'sleep_time'  => 2,\n    'tmp_path'    => './.plinker',\n    'auto_update' => 86400\n]);\n\n$task->daemon('Queue');\n\n\n\nMaking a remote call.\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1/examples/tasks/server.php',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ],\n\n    // displays output to task runner console\n    'debug' => true,\n\n    // daemon sleep time\n    'sleep_time' => 1,\n    'tmp_path'   => './.plinker'\n];\n\n// init plinker client\n$tasks = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Tasks\\Manager',\n\n    // keys\n    hash('sha256', gmdate('h').$config['plinker']['public_key']),\n    hash('sha256', gmdate('h').$config['plinker']['private_key']),\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);\n\n/**\n * Example\n */\n\n// create the task\ntry {\n    // create task\n    $tasks->create(\n        // name\n        'Hello World',\n        // source\n        '<?php echo \"Hello World\";',\n        // type\n        'php',\n        // description\n        '...',\n        // default params\n        []\n    );\n} catch (\\Exception $e) {\n    if ($e->getMessage() == 'Unauthorised') {\n        echo 'Error: Connected successfully but could not authenticate! Check public and private keys.';\n    } else {\n        echo 'Error:'.str_replace('Could not unserialize response:', '', trim(htmlentities($e->getMessage())));\n    }\n}\n\n//run task now - executed as apache user\n//print_r($tasks->runNow('Hello World'));\n\n// place task in queue to run\nprint_r($tasks->run('Hello World', [1], 5));\n\n// get task status\nprint_r($tasks->status('Hello World'));\n\n// get task run count\nprint_r($tasks->runCount('Hello World'));\n\n// clear all tasks\n//$tasks->clear();\n\n\n\nthen the server part...\n\n\n<?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Plinker Server\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Plinker Config\n     */\n    $plinker = [\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ];\n\n    /**\n     * Plinker server listener\n     */\n    if (isset($_POST['data']) &&\n        isset($_POST['token']) &&\n        isset($_POST['public_key'])\n    ) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        //\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            hash('sha256', gmdate('h').$plinker['public_key']),\n            hash('sha256', gmdate('h').$plinker['private_key'])\n        );\n\n        exit($server->execute());\n    }\n}\n\n\n\nSee the \norganisations page\n for additional components and examples.",
            "title": "Tasks"
        },
        {
            "location": "/tasks/#plinker-rpc-tasks",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  The tasks component allows you to write code based tasks which are completed by a daemon, \nthis could allow you to create a single interface to control a cluster of servers tasks.  Want to see an example project? Check out  PlinkerUI .  Composer  {\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/tasks\": \">=v0.1\"\n    }\n}  Example source  You should create a file which will be run via cron, for example:  cron.php  <?php\nrequire '../../vendor/autoload.php';\n\n/*\n * The cron job\n *\n * @reboot while sleep 1; do cd /var/www/html/examples/tasks && /usr/bin/php run.php ; done\n */\n\nif (php_sapi_name() != 'cli') {\n    header('HTTP/1.0 403 Forbidden');\n    exit('CLI script');\n}\n\n$task = new Plinker\\Tasks\\Runner([\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false\n    ],\n    'debug'       => true,\n    'log'         => true,\n    'sleep_time'  => 2,\n    'tmp_path'    => './.plinker',\n    'auto_update' => 86400\n]);\n\n$task->daemon('Queue');",
            "title": "Plinker-RPC - Tasks"
        },
        {
            "location": "/tasks/#making-a-remote-call",
            "text": "<?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Plinker Config\n */\n$config = [\n    // plinker connection\n    'plinker' => [\n        'endpoint' => 'http://127.0.0.1/examples/tasks/server.php',\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ],\n\n    // database connection\n    'database' => [\n        'dsn'      => 'sqlite:./.plinker/database.db',\n        'host'     => '',\n        'name'     => '',\n        'username' => '',\n        'password' => '',\n        'freeze'   => false,\n        'debug'    => false,\n    ],\n\n    // displays output to task runner console\n    'debug' => true,\n\n    // daemon sleep time\n    'sleep_time' => 1,\n    'tmp_path'   => './.plinker'\n];\n\n// init plinker client\n$tasks = new \\Plinker\\Core\\Client(\n    // where is the plinker server\n    $config['plinker']['endpoint'],\n\n    // component namespace to interface to\n    'Tasks\\Manager',\n\n    // keys\n    hash('sha256', gmdate('h').$config['plinker']['public_key']),\n    hash('sha256', gmdate('h').$config['plinker']['private_key']),\n\n    // construct values which you pass to the component, which the component\n    //  will use, for RedbeanPHP component you would send the database connection\n    //  dont worry its AES encrypted. see: encryption-proof.txt\n    $config\n);\n\n/**\n * Example\n */\n\n// create the task\ntry {\n    // create task\n    $tasks->create(\n        // name\n        'Hello World',\n        // source\n        '<?php echo \"Hello World\";',\n        // type\n        'php',\n        // description\n        '...',\n        // default params\n        []\n    );\n} catch (\\Exception $e) {\n    if ($e->getMessage() == 'Unauthorised') {\n        echo 'Error: Connected successfully but could not authenticate! Check public and private keys.';\n    } else {\n        echo 'Error:'.str_replace('Could not unserialize response:', '', trim(htmlentities($e->getMessage())));\n    }\n}\n\n//run task now - executed as apache user\n//print_r($tasks->runNow('Hello World'));\n\n// place task in queue to run\nprint_r($tasks->run('Hello World', [1], 5));\n\n// get task status\nprint_r($tasks->status('Hello World'));\n\n// get task run count\nprint_r($tasks->runCount('Hello World'));\n\n// clear all tasks\n//$tasks->clear();  then the server part...  <?php\nrequire '../../vendor/autoload.php';\n\n/**\n * Plinker Server\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n\n    /**\n     * Plinker Config\n     */\n    $plinker = [\n        'public_key'  => 'makeSomethingUp',\n        'private_key' => 'againMakeSomethingUp'\n    ];\n\n    /**\n     * Plinker server listener\n     */\n    if (isset($_POST['data']) &&\n        isset($_POST['token']) &&\n        isset($_POST['public_key'])\n    ) {\n        // test its encrypted\n        file_put_contents('./.plinker/encryption-proof.txt', print_r($_POST, true));\n\n        //\n        $server = new \\Plinker\\Core\\Server(\n            $_POST,\n            hash('sha256', gmdate('h').$plinker['public_key']),\n            hash('sha256', gmdate('h').$plinker['private_key'])\n        );\n\n        exit($server->execute());\n    }\n}  See the  organisations page  for additional components and examples.",
            "title": "Making a remote call."
        },
        {
            "location": "/test/",
            "text": "Plinker-RPC - Test/Demo\n\n\nPlinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA Test component which simply returns back what you sent, for testing/example purposes.\n\n\nComposer\n\n\n{\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/test\": \">=v0.1\"\n    }\n}\n\n\n\nMaking a remote call.\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';\n\n\n\nthen the server part...\n\n\n<?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}\n\n\n\nSee the \norganisations page\n for additional components.",
            "title": "Test"
        },
        {
            "location": "/test/#plinker-rpc-testdemo",
            "text": "Plinker PHP RPC client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.  A Test component which simply returns back what you sent, for testing/example purposes.  Composer  {\n    \"require\": {\n        \"plinker/core\": \">=v0.1\",\n        \"plinker/test\": \">=v0.1\"\n    }\n}",
            "title": "Plinker-RPC - Test/Demo"
        },
        {
            "location": "/test/#making-a-remote-call",
            "text": "<?php\nrequire 'vendor/autoload.php';\n\n/**\n * Initialize plinker client.\n *\n * @param string $url to host\n * @param string $component namespace of class to interface to\n * @param string $public_key to authenticate on host\n * @param string $private_key to authenticate on host\n * @param string $config component construct config\n */\n$plink = new Plinker\\Core\\Client(\n    'http://example.com',\n    'Test\\Demo',\n    'username',\n    'password',\n    array(\n        'time' => time()\n    )\n);\necho '<pre>'.print_r($plink->test(), true).'</pre>';  then the server part...  <?php\nrequire 'vendor/autoload.php';\n\n/**\n * POST Server Part\n */\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $server = new Plinker\\Core\\Server(\n        $_POST,\n        'username',\n        'password'\n    );\n    exit($server->execute());\n}  See the  organisations page  for additional components.",
            "title": "Making a remote call."
        }
    ]
}